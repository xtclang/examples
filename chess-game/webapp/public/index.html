<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chess Playground</title>
  
  <!-- Google Fonts: Space Grotesk for modern, clean typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet" />
  
  <style>
    /* ===== CSS Custom Properties (Variables) ===== */
    :root {
      /* Color Palette */
      --bg: #0f1629;              /* Dark background */
      --panel: #0d2136;           /* Panel background */
      --accent: #e3b341;          /* Gold accent color */
      --accent-secondary: #37b2ff; /* Blue accent for multiplayer */
      --muted: #7c8aa5;           /* Muted text color */
      --light: #f5f7fb;           /* Light text color */
      --dark-square: #20344e;     /* Dark chess squares */
      --light-square: #2e4467;    /* Light chess squares */
      --selection: #b0e3ff;       /* Selected square highlight */
      --success: #4ade80;         /* Success/green color */
      --warning: #fbbf24;         /* Warning/yellow color */
      --shadow: 0 10px 50px rgba(0, 0, 0, 0.35);  /* Drop shadow */
    }

    /* ===== Base Styles ===== */
    
    /* Reset box-sizing for all elements */
    * { box-sizing: border-box; }
    
    /* Body: Full viewport height with gradient background */
    body {
      margin: 0;
      min-height: 100vh;
      /* Multi-layer radial gradient for visual depth */
      background: radial-gradient(circle at 20% 20%, rgba(227, 179, 65, 0.12), transparent 30%),
                  radial-gradient(circle at 80% 0%, rgba(55, 178, 255, 0.18), transparent 30%),
                  var(--bg);
      font-family: "Space Grotesk", system-ui, sans-serif;
      color: var(--light);
      /* Center content vertically and horizontally */
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 32px;
    }

    /* ===== Layout Styles ===== */
    
    /* Main container: Two-column grid layout (board + controls) */
    main {
      width: min(1200px, 100%);  /* Max 1200px, responsive below that */
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;  /* Board slightly larger than controls */
      gap: 28px;
      align-items: start;
    }

    /* Panel sections for containing content */
    section {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.05);  /* Subtle border */
      border-radius: 18px;
      padding: 22px;
      box-shadow: var(--shadow);
    }

    /* Board pane: Transparent to show background gradient */
    .board-pane {
      background: transparent;
      border: none;
      padding: 0;
      box-shadow: none;
    }

    /* ===== Typography ===== */
    
    /* Main heading */
    h1 {
      margin: 0 0 8px;
      font-size: 28px;
      letter-spacing: -0.5px;  /* Tighter spacing for modern look */
    }

    /* Subtitle/description text */
    .subtitle {
      margin: 0 0 16px;
      color: var(--muted);
      font-size: 15px;
    }

    /* ===== Chess Board Styles ===== */
    
    /* Board container: 8x8 grid of squares */
    .board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);  /* 8 equal columns */
      width: min(82vmin, 680px);  /* Responsive size, max 680px */
      aspect-ratio: 1 / 1;        /* Perfect square */
      border-radius: 18px;
      overflow: hidden;           /* Clip square corners */
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);  /* Inner glow */
      margin: 0 auto;
    }

    /* Individual chess square (button) */
    .square {
      border: none;
      width: 100%;
      height: 100%;
      font-size: 32px;            /* Chess piece symbol size */
      color: var(--light);
      display: grid;
      place-items: center;        /* Center piece symbol */
      cursor: pointer;
      /* Smooth hover and interaction transitions */
      transition: background 0.15s ease, transform 0.05s ease;
    }

    /* Dark squares (like a1, c1, etc.) */
    .square.dark { background: var(--dark-square); }
    
    /* Light squares (like a2, b1, etc.) */
    .square.light { background: var(--light-square); }
    
    /* Selected square highlight */
    .square.selected { 
      outline: 2px solid var(--selection); 
      outline-offset: -4px;  /* Inset outline */
    }
    
    /* Hover effect: slight lift */
    .square:hover { transform: translateY(-1px); }

    /* Disabled board (not your turn) */
    .board.disabled .square {
      cursor: not-allowed;
      opacity: 0.8;
    }

    /* ===== Status Display Styles ===== */
    
    /* Status bar: Two-column grid for turn and game status */
    .status {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));  /* Equal columns */
      gap: 12px;
      margin: 0 0 16px;
    }

    /* Scoreboard: Two-column grid for player scores */
    .scoreboard {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
      margin: 0 0 16px;
    }

    /* Card component: Container for status/score items */
    .card {
      background: rgba(255, 255, 255, 0.03);  /* Subtle background */
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 12px 14px;
      border-radius: 12px;
    }

    /* Label text in cards (e.g., "Turn", "Status") */
    .label { 
      color: var(--muted); 
      font-size: 13px; 
      margin-bottom: 6px; 
    }
    
    /* Value text in cards (e.g., "White", "Ongoing") */
    .value { 
      font-size: 18px; 
      font-weight: 600; 
    }

    /* ===== Button Styles ===== */
    
    /* Action buttons container */
    .actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;  /* Wrap on small screens */
      margin-bottom: 12px;
    }

    /* Primary action button (e.g., Reset Game) */
    button.action {
      padding: 10px 14px;
      border-radius: 10px;
      background: var(--accent);  /* Gold background */
      border: none;
      color: #1c1605;             /* Dark text for contrast */
      font-weight: 700;
      letter-spacing: 0.25px;
      cursor: pointer;
      /* Smooth hover animation */
      transition: transform 0.12s ease, box-shadow 0.12s ease;
      box-shadow: 0 8px 24px rgba(227, 179, 65, 0.35);  /* Gold glow */
    }

    /* Secondary button style (e.g., Refresh State) */
    button.action.secondary {
      background: rgba(255, 255, 255, 0.08);  /* Translucent background */
      color: var(--light);
      box-shadow: none;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Multiplayer button style */
    button.action.multiplayer {
      background: var(--accent-secondary);
      box-shadow: 0 8px 24px rgba(55, 178, 255, 0.35);
    }

    /* Leave/danger button style */
    button.action.danger {
      background: #ef4444;
      box-shadow: 0 8px 24px rgba(239, 68, 68, 0.35);
    }

    /* Button hover: Slight lift effect */
    button.action:hover { transform: translateY(-1px); }

    /* Disabled button state */
    button.action:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* ===== Log Display ===== */
    
    /* Message log area */
    .log {
      background: rgba(0, 0, 0, 0.22);  /* Dark background */
      border-radius: 12px;
      padding: 12px;
      min-height: 120px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-size: 14px;
      line-height: 1.5;
      white-space: pre-wrap;
    }

    /* ===== Pill Badge Component ===== */
    
    /* Status pill with indicator dot */
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;  /* Fully rounded ends */
      padding: 6px 10px;
      font-size: 13px;
      color: var(--light);
    }

    /* Animated dot indicator before pill text */
    .pill::before {
      content: '';
      width: 8px;
      height: 8px;
      border-radius: 50%;  /* Circle */
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(227, 179, 65, 0.22);  /* Glow effect */
    }

    /* Multiplayer pill */
    .pill.multiplayer::before {
      background: var(--accent-secondary);
      box-shadow: 0 0 0 3px rgba(55, 178, 255, 0.22);
    }

    /* Waiting pill animation */
    .pill.waiting::before {
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }

    /* ===== Mode Selection Styles ===== */

    .mode-selector {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 16px;
    }

    .mode-btn {
      padding: 16px;
      border-radius: 12px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.03);
      color: var(--light);
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }

    .mode-btn:hover {
      border-color: var(--accent);
      background: rgba(227, 179, 65, 0.1);
    }

    .mode-btn.active {
      border-color: var(--accent);
      background: rgba(227, 179, 65, 0.15);
    }

    .mode-btn.multiplayer-btn:hover,
    .mode-btn.multiplayer-btn.active {
      border-color: var(--accent-secondary);
      background: rgba(55, 178, 255, 0.15);
    }

    .mode-btn h3 {
      margin: 0 0 4px;
      font-size: 16px;
    }

    .mode-btn p {
      margin: 0;
      font-size: 12px;
      color: var(--muted);
    }

    /* ===== Lobby Styles ===== */

    .lobby-panel {
      margin-bottom: 16px;
    }

    .lobby-input-group {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }

    .lobby-input {
      flex: 1;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(0, 0, 0, 0.2);
      color: var(--light);
      font-size: 16px;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .lobby-input::placeholder {
      text-transform: none;
      letter-spacing: normal;
      color: var(--muted);
    }

    .room-code-display {
      background: rgba(55, 178, 255, 0.1);
      border: 2px dashed var(--accent-secondary);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      margin-bottom: 12px;
    }

    .room-code-display .code {
      font-size: 32px;
      font-weight: 700;
      letter-spacing: 4px;
      color: var(--accent-secondary);
    }

    .room-code-display .hint {
      font-size: 13px;
      color: var(--muted);
      margin-top: 8px;
    }

    /* Player color indicator */
    .player-color {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 600;
    }

    .player-color.white {
      background: rgba(255, 255, 255, 0.15);
    }

    .player-color.black {
      background: rgba(0, 0, 0, 0.4);
    }

    .player-color .piece {
      font-size: 20px;
    }

    /* Hide elements based on game mode */
    .single-player-only { display: none; }
    .multiplayer-only { display: none; }

    body.mode-single .single-player-only { display: block; }
    body.mode-single .multiplayer-only { display: none; }
    body.mode-multi .single-player-only { display: none; }
    body.mode-multi .multiplayer-only { display: block; }

    /* ===== Responsive Design ===== */
    
    /* Mobile/tablet layout: Stack board and controls vertically */
    @media (max-width: 960px) {
      body { padding: 16px; }
      main { 
        grid-template-columns: 1fr;  /* Single column layout */
      }
    }
  </style>
</head>
<body class="mode-single">
  <main>
    <!-- Left Panel: Chess Board -->
    <section class="board-pane">
      <h1>Chess Playground</h1>
      <p class="subtitle">Pick a square to move from, then a square to move to. All logic lives on the server.</p>
      <!-- 8x8 chess board grid (populated by JavaScript) -->
      <div id="board" class="board"></div>
    </section>

    <!-- Right Panel: Game Controls and Status -->
    <section>
      <!-- Mode Selection -->
      <div class="mode-selector" id="modeSelector">
        <button class="mode-btn active" id="singlePlayerBtn">
          <h3>ðŸ¤– vs AI</h3>
          <p>Play against the computer</p>
        </button>
        <button class="mode-btn multiplayer-btn" id="multiplayerBtn">
          <h3>ðŸ‘¥ Online</h3>
          <p>Play with a friend</p>
        </button>
      </div>

      <!-- Multiplayer Lobby (shown when in multiplayer mode) -->
      <div class="lobby-panel multiplayer-only" id="lobbyPanel">
        <div id="lobbyContent">
          <!-- Create or Join options -->
          <div id="lobbyOptions">
            <div class="actions" style="margin-bottom: 16px;">
              <button class="action multiplayer" id="createRoomBtn">Create Room</button>
            </div>
            <div class="lobby-input-group">
              <input type="text" class="lobby-input" id="roomCodeInput" placeholder="Enter room code" maxlength="6" />
              <button class="action multiplayer" id="joinRoomBtn">Join</button>
            </div>
          </div>

          <!-- Room info (shown when in a room) -->
          <div id="roomInfo" style="display: none;">
            <div class="room-code-display">
              <div class="code" id="roomCodeDisplay">------</div>
              <div class="hint">Share this code with your opponent</div>
            </div>
            <div class="card" style="margin-bottom: 12px;">
              <div class="label">You are playing as</div>
              <div class="value">
                <span class="player-color white" id="playerColorDisplay">
                  <span class="piece">â™”</span> White
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Turn and Status Display -->
      <div class="status">
        <div class="card">
          <div class="label">Turn</div>
          <div class="value" id="turn">â€¦</div>
        </div>
        <div class="card">
          <div class="label">Status</div>
          <div class="value" id="status">â€¦</div>
        </div>
      </div>

      <!-- Multiplayer-specific status -->
      <div class="card multiplayer-only" style="margin-bottom: 16px;" id="multiplayerStatus">
        <div class="label">Game Status</div>
        <div class="value">
          <span class="pill multiplayer waiting" id="mpStatusPill">Waiting for opponent...</span>
        </div>
      </div>

      <!-- Player Scores Display -->
      <div class="scoreboard">
        <div class="card">
          <div class="label single-player-only">Your Score</div>
          <div class="label multiplayer-only">White Score</div>
          <div class="value" id="playerScore">0</div>
        </div>
        <div class="card">
          <div class="label single-player-only">Opponent Score</div>
          <div class="label multiplayer-only">Black Score</div>
          <div class="value" id="opponentScore">0</div>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="actions">
        <button class="action" id="reset">Reset Game</button>
        <button class="action secondary" id="refresh">Refresh State</button>
        <button class="action danger multiplayer-only" id="leaveRoom" style="display: none;">Leave Room</button>
      </div>

      <!-- Current Selection Display -->
      <div class="card" style="margin-bottom: 12px;">
        <div class="label">Selection</div>
        <div class="value" id="selection">Pick any square</div>
      </div>

      <!-- Message Log -->
      <div class="log" id="log">Waiting for serverâ€¦</div>
    </section>
  </main>

  <script>
    // ===== DOM Element References =====
    const boardEl = document.getElementById('board');
    const turnEl = document.getElementById('turn');
    const statusEl = document.getElementById('status');
    const selectionEl = document.getElementById('selection');
    const logEl = document.getElementById('log');
    const playerScoreEl = document.getElementById('playerScore');
    const opponentScoreEl = document.getElementById('opponentScore');
    const resetBtn = document.getElementById('reset');
    const refreshBtn = document.getElementById('refresh');
    
    // Mode selection elements
    const singlePlayerBtn = document.getElementById('singlePlayerBtn');
    const multiplayerBtn = document.getElementById('multiplayerBtn');
    const modeSelector = document.getElementById('modeSelector');
    
    // Multiplayer elements
    const lobbyPanel = document.getElementById('lobbyPanel');
    const lobbyOptions = document.getElementById('lobbyOptions');
    const roomInfo = document.getElementById('roomInfo');
    const createRoomBtn = document.getElementById('createRoomBtn');
    const joinRoomBtn = document.getElementById('joinRoomBtn');
    const roomCodeInput = document.getElementById('roomCodeInput');
    const roomCodeDisplay = document.getElementById('roomCodeDisplay');
    const playerColorDisplay = document.getElementById('playerColorDisplay');
    const leaveRoomBtn = document.getElementById('leaveRoom');
    const mpStatusPill = document.getElementById('mpStatusPill');
    const multiplayerStatus = document.getElementById('multiplayerStatus');

    // ===== Chess Piece Mapping =====
    const pieceMap = {
      r: 'â™œ', n: 'â™ž', b: 'â™', q: 'â™›', k: 'â™š', p: 'â™Ÿ',
      R: 'â™–', N: 'â™˜', B: 'â™—', Q: 'â™•', K: 'â™”', P: 'â™™',
      '.': ''
    };

    // ===== Application State =====
    let selection = null;
    let cachedBoard = [];
    let opponentRefresh = null;
    
    // Game mode state
    let gameMode = 'single'; // 'single' or 'multi'
    let roomCode = null;
    let playerId = null;
    let playerColor = null;
    let isInRoom = false;

    // ===== Utility Functions =====

    function algebraic(row, col) {
      const file = String.fromCharCode('a'.charCodeAt(0) + col);
      const rank = 8 - row;
      return `${file}${rank}`;
    }

    function setMessage(text) {
      logEl.textContent = text;
    }

    function saveSession() {
      if (gameMode === 'multi' && roomCode && playerId) {
        localStorage.setItem('chess_session', JSON.stringify({
          roomCode, playerId, playerColor
        }));
      } else {
        localStorage.removeItem('chess_session');
      }
    }

    function loadSession() {
      try {
        const session = JSON.parse(localStorage.getItem('chess_session'));
        if (session && session.roomCode && session.playerId) {
          return session;
        }
      } catch (e) {}
      return null;
    }

    // ===== Board Rendering =====

    function renderBoard(boardRows, disabled = false) {
      cachedBoard = boardRows;
      boardEl.innerHTML = '';
      boardEl.classList.toggle('disabled', disabled);
      
      boardRows.forEach((rowString, rowIdx) => {
        [...rowString].forEach((ch, colIdx) => {
          const btn = document.createElement('button');
          btn.className = `square ${(rowIdx + colIdx) % 2 === 0 ? 'dark' : 'light'}`;
          btn.dataset.square = algebraic(rowIdx, colIdx);
          btn.textContent = pieceMap[ch] ?? '';
          
          if (selection === btn.dataset.square) {
            btn.classList.add('selected');
          }
          
          if (!disabled) {
            btn.addEventListener('click', () => handleSquareClick(btn.dataset.square));
          }
          
          boardEl.appendChild(btn);
        });
      });
    }

    // ===== Move Handling =====

    function handleSquareClick(square) {
      if (!selection) {
        selection = square;
        selectionEl.textContent = `From ${square}`;
        renderBoard(cachedBoard, false);
        return;
      }

      if (selection === square) {
        selection = null;
        selectionEl.textContent = 'Pick any square';
        renderBoard(cachedBoard, false);
        return;
      }

      const from = selection;
      const to = square;
      selection = null;
      selectionEl.textContent = 'Sending moveâ€¦';
      
      if (gameMode === 'multi' && isInRoom) {
        sendOnlineMove(from, to);
      } else {
        sendMove(from, to);
      }
    }

    // ===== Single Player API =====

    async function sendMove(from, to) {
      try {
        const res = await fetch(`/api/move/${from}/${to}`, { method: 'POST' });
        const payload = await res.json();
        applyState(payload);
        selectionEl.textContent = 'Pick any square';
      } catch (err) {
        setMessage('Move failed: ' + err.message);
      }
    }

    async function loadState() {
      setMessage('Syncing with serverâ€¦');
      try {
        const res = await fetch('/api/state');
        const payload = await res.json();
        applyState(payload);
      } catch (err) {
        setMessage('Could not reach the chess server.');
      }
    }

    async function resetGame() {
      setMessage('Resettingâ€¦');
      try {
        if (gameMode === 'multi' && isInRoom) {
          await resetOnlineGame();
        } else {
          const res = await fetch('/api/reset', { method: 'POST' });
          const payload = await res.json();
          applyState(payload);
        }
      } catch (err) {
        setMessage('Reset failed: ' + err.message);
      }
    }

    function applyState(state) {
      if (!state || !state.board) {
        setMessage('Unexpected response from server.');
        return;
      }
      
      if (opponentRefresh !== null) {
        clearTimeout(opponentRefresh);
        opponentRefresh = null;
      }
      
      renderBoard(state.board, false);
      turnEl.textContent = state.turn ?? 'â€”';
      statusEl.textContent = state.status ?? 'â€”';
      selectionEl.textContent = 'Pick any square';
      playerScoreEl.textContent = state.playerScore ?? 0;
      opponentScoreEl.textContent = state.opponentScore ?? 0;
      
      const move = state.lastMove ? `Last move: ${state.lastMove}` : 'Ready for a move';
      setMessage(`${state.message || 'Synced.'}\n${move}`);
      
      if (state.opponentPending) {
        opponentRefresh = setTimeout(loadState, 3100);
      }
    }

    // ===== Multiplayer API =====

    async function createRoom() {
      setMessage('Creating roomâ€¦');
      try {
        const res = await fetch('/api/online/create', { method: 'POST' });
        const data = await res.json();
        
        if (data.roomCode && data.playerId) {
          roomCode = data.roomCode;
          playerId = data.playerId;
          playerColor = 'White';
          isInRoom = true;
          
          saveSession();
          showRoomInfo();
          setMessage(data.message || 'Room created!');
          
          // Start polling for opponent
          startMultiplayerPolling();
        } else {
          setMessage('Failed to create room.');
        }
      } catch (err) {
        setMessage('Failed to create room: ' + err.message);
      }
    }

    async function joinRoom(code) {
      if (!code || code.length < 4) {
        setMessage('Please enter a valid room code.');
        return;
      }
      
      setMessage('Joining roomâ€¦');
      try {
        const res = await fetch(`/api/online/join/${code.toUpperCase()}`, { method: 'POST' });
        const data = await res.json();
        
        // Check if message contains JOIN_SUCCESS with player ID
        if (data.message && data.message.startsWith('JOIN_SUCCESS:')) {
          const parts = data.message.split(':');
          roomCode = data.roomCode || code.toUpperCase();
          playerId = parts[1];
          playerColor = parts[2] || 'Black';
          isInRoom = true;
          
          saveSession();
          showRoomInfo();
          setMessage('Joined the game as Black. White moves first.');
          
          // Load initial state and start polling
          await loadOnlineState();
          startMultiplayerPolling();
        } else if (data.message) {
          // Error response
          setMessage(data.message);
        } else {
          setMessage('Failed to join room.');
        }
      } catch (err) {
        setMessage('Failed to join room: ' + err.message);
      }
    }

    async function loadOnlineState() {
      if (!roomCode || !playerId) return;
      
      try {
        const res = await fetch(`/api/online/state/${roomCode}/${playerId}`);
        const state = await res.json();
        applyOnlineState(state);
      } catch (err) {
        setMessage('Failed to load game state: ' + err.message);
      }
    }

    async function sendOnlineMove(from, to) {
      if (!roomCode || !playerId) return;
      
      try {
        const res = await fetch(`/api/online/move/${roomCode}/${playerId}/${from}/${to}`, {
          method: 'POST'
        });
        const state = await res.json();
        applyOnlineState(state);
        selectionEl.textContent = 'Pick any square';
      } catch (err) {
        setMessage('Move failed: ' + err.message);
      }
    }

    async function resetOnlineGame() {
      if (!roomCode || !playerId) return;
      
      try {
        const res = await fetch(`/api/online/reset/${roomCode}/${playerId}`, {
          method: 'POST'
        });
        const state = await res.json();
        applyOnlineState(state);
      } catch (err) {
        setMessage('Reset failed: ' + err.message);
      }
    }

    async function leaveRoom() {
      if (!roomCode || !playerId) {
        exitMultiplayerMode();
        return;
      }
      
      try {
        await fetch(`/api/online/leave/${roomCode}/${playerId}`, { method: 'POST' });
      } catch (err) {
        // Ignore errors, we're leaving anyway
      }
      
      exitMultiplayerMode();
      setMessage('You left the room.');
    }

    function applyOnlineState(state) {
      if (!state) {
        setMessage('Unexpected response from server.');
        return;
      }
      
      if (opponentRefresh !== null) {
        clearTimeout(opponentRefresh);
        opponentRefresh = null;
      }
      
      // Update board (disabled if not your turn)
      const disabled = !state.isYourTurn && state.status === 'Ongoing';
      if (state.board && state.board.length > 0) {
        renderBoard(state.board, disabled);
      }
      
      turnEl.textContent = state.turn ?? 'â€”';
      statusEl.textContent = state.status ?? 'â€”';
      selectionEl.textContent = state.isYourTurn ? 'Your turn - pick a square' : 'Waiting for opponent';
      playerScoreEl.textContent = state.playerScore ?? 0;
      opponentScoreEl.textContent = state.opponentScore ?? 0;
      
      // Update multiplayer status pill
      if (state.waitingForOpponent) {
        mpStatusPill.textContent = 'Waiting for opponent to join...';
        mpStatusPill.classList.add('waiting');
      } else if (state.isYourTurn) {
        mpStatusPill.textContent = 'Your turn!';
        mpStatusPill.classList.remove('waiting');
      } else if (state.status === 'Ongoing') {
        mpStatusPill.textContent = "Opponent's turn...";
        mpStatusPill.classList.add('waiting');
      } else {
        mpStatusPill.textContent = state.status;
        mpStatusPill.classList.remove('waiting');
      }
      
      const move = state.lastMove ? `Last move: ${state.lastMove}` : '';
      setMessage(`${state.message || 'Synced.'}\n${move}`);
      
      // Continue polling if waiting for opponent or it's not our turn
      if (state.status === 'Ongoing' && (state.waitingForOpponent || !state.isYourTurn)) {
        opponentRefresh = setTimeout(loadOnlineState, 2000);
      }
    }

    function startMultiplayerPolling() {
      if (opponentRefresh !== null) {
        clearTimeout(opponentRefresh);
      }
      loadOnlineState();
    }

    // ===== UI State Management =====

    function showRoomInfo() {
      lobbyOptions.style.display = 'none';
      roomInfo.style.display = 'block';
      modeSelector.style.display = 'none';
      leaveRoomBtn.style.display = 'inline-block';
      
      roomCodeDisplay.textContent = roomCode || '------';
      
      if (playerColor === 'White') {
        playerColorDisplay.innerHTML = '<span class="piece">â™”</span> White';
        playerColorDisplay.className = 'player-color white';
      } else {
        playerColorDisplay.innerHTML = '<span class="piece">â™š</span> Black';
        playerColorDisplay.className = 'player-color black';
      }
    }

    function showLobbyOptions() {
      lobbyOptions.style.display = 'block';
      roomInfo.style.display = 'none';
      modeSelector.style.display = 'grid';
      leaveRoomBtn.style.display = 'none';
    }

    function setGameMode(mode) {
      gameMode = mode;
      document.body.classList.remove('mode-single', 'mode-multi');
      document.body.classList.add(mode === 'single' ? 'mode-single' : 'mode-multi');
      
      singlePlayerBtn.classList.toggle('active', mode === 'single');
      multiplayerBtn.classList.toggle('active', mode === 'multi');
      
      if (mode === 'single') {
        if (opponentRefresh !== null) {
          clearTimeout(opponentRefresh);
          opponentRefresh = null;
        }
        loadState();
      } else {
        showLobbyOptions();
      }
    }

    function exitMultiplayerMode() {
      roomCode = null;
      playerId = null;
      playerColor = null;
      isInRoom = false;
      localStorage.removeItem('chess_session');
      
      if (opponentRefresh !== null) {
        clearTimeout(opponentRefresh);
        opponentRefresh = null;
      }
      
      showLobbyOptions();
      renderBoard(['rnbqkbnr', 'pppppppp', '........', '........', '........', '........', 'PPPPPPPP', 'RNBQKBNR'], true);
    }

    // ===== Event Listeners =====

    resetBtn.addEventListener('click', resetGame);
    refreshBtn.addEventListener('click', () => {
      if (gameMode === 'multi' && isInRoom) {
        loadOnlineState();
      } else {
        loadState();
      }
    });

    singlePlayerBtn.addEventListener('click', () => setGameMode('single'));
    multiplayerBtn.addEventListener('click', () => setGameMode('multi'));

    createRoomBtn.addEventListener('click', createRoom);
    joinRoomBtn.addEventListener('click', () => joinRoom(roomCodeInput.value));
    roomCodeInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') joinRoom(roomCodeInput.value);
    });
    leaveRoomBtn.addEventListener('click', leaveRoom);

    // ===== Initialization =====

    // Check for existing session
    const savedSession = loadSession();
    if (savedSession) {
      gameMode = 'multi';
      roomCode = savedSession.roomCode;
      playerId = savedSession.playerId;
      playerColor = savedSession.playerColor;
      isInRoom = true;
      
      document.body.classList.remove('mode-single');
      document.body.classList.add('mode-multi');
      multiplayerBtn.classList.add('active');
      singlePlayerBtn.classList.remove('active');
      
      showRoomInfo();
      startMultiplayerPolling();
    } else {
      // Default to single player mode
      loadState();
    }
  </script>
</body>
</html>
