<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chess Playground</title>
  
  <!-- Google Fonts: Space Grotesk for modern, clean typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet" />
  
  <style>
    /* ===== CSS Custom Properties (Variables) ===== */
    :root {
      /* Color Palette */
      --bg: #0f1629;              /* Dark background */
      --panel: #0d2136;           /* Panel background */
      --accent: #e3b341;          /* Gold accent color */
      --accent-secondary: #37b2ff; /* Blue accent for multiplayer */
      --muted: #7c8aa5;           /* Muted text color */
      --light: #f5f7fb;           /* Light text color */
      --dark-square: #20344e;     /* Dark chess squares */
      --light-square: #2e4467;    /* Light chess squares */
      --selection: #b0e3ff;       /* Selected square highlight */
      --success: #4ade80;         /* Success/green color */
      --warning: #fbbf24;         /* Warning/yellow color */
      --shadow: 0 10px 50px rgba(0, 0, 0, 0.35);  /* Drop shadow */
      --last-move: rgba(227, 179, 65, 0.35);  /* Last move highlight */
      --last-move-border: rgba(227, 179, 65, 0.6);  /* Last move border */
    }

    /* ===== Base Styles ===== */
    
    /* Reset box-sizing for all elements */
    * { box-sizing: border-box; }
    
    /* Body: Full viewport height with gradient background */
    body {
      margin: 0;
      min-height: 100vh;
      /* Multi-layer radial gradient for visual depth */
      background: radial-gradient(circle at 20% 20%, rgba(227, 179, 65, 0.12), transparent 30%),
                  radial-gradient(circle at 80% 0%, rgba(55, 178, 255, 0.18), transparent 30%),
                  var(--bg);
      font-family: "Space Grotesk", system-ui, sans-serif;
      color: var(--light);
      /* Center content vertically and horizontally */
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    /* ===== Layout Styles ===== */
    
    /* Main container: Centered board-first layout */
    main {
      width: min(1400px, 100%);
      display: flex;
      gap: 24px;
      align-items: flex-start;
      justify-content: center;
    }

    /* Panel sections for containing content */
    section {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.05);  /* Subtle border */
      border-radius: 18px;
      padding: 18px;
      box-shadow: var(--shadow);
    }

    /* Board pane: Transparent to show background gradient */
    .board-pane {
      background: transparent;
      border: none;
      padding: 0;
      box-shadow: none;
      flex-shrink: 0;
    }

    /* Side panel - compact width */
    .side-panel {
      width: 320px;
      flex-shrink: 0;
    }

    /* ===== Typography ===== */
    
    /* Main heading */
    h1 {
      margin: 0 0 4px;
      font-size: 24px;
      letter-spacing: -0.5px;  /* Tighter spacing for modern look */
    }

    /* Subtitle/description text */
    .subtitle {
      margin: 0 0 12px;
      color: var(--muted);
      font-size: 13px;
    }

    /* ===== Chess Board Styles ===== */
    
    /* Board container: 8x8 grid of squares */
    .board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);  /* 8 equal columns */
      width: min(75vmin, 600px);  /* Responsive size */
      aspect-ratio: 1 / 1;        /* Perfect square */
      border-radius: 14px;
      overflow: hidden;           /* Clip square corners */
      border: 2px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 15px 60px rgba(0, 0, 0, 0.4), inset 0 0 0 1px rgba(255, 255, 255, 0.04);
      margin: 0 auto;
    }

    /* Individual chess square (button) */
    .square {
      border: none;
      width: 100%;
      height: 100%;
      aspect-ratio: 1 / 1;        /* Force square shape */
      font-size: clamp(28px, 5vmin, 42px);  /* Responsive piece size */
      color: var(--light);
      display: grid;
      place-items: center;        /* Center piece symbol */
      cursor: pointer;
      position: relative;         /* For absolute positioning of indicators */
      /* Smooth hover and interaction transitions */
      transition: background 0.15s ease, transform 0.05s ease, box-shadow 0.15s ease;
      padding: 0;
      margin: 0;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    /* Dark squares (like a1, c1, etc.) */
    .square.dark { background: var(--dark-square); }
    
    /* Light squares (like a2, b1, etc.) */
    .square.light { background: var(--light-square); }
    
    /* Selected square highlight */
    .square.selected { 
      background: rgba(176, 227, 255, 0.4) !important;
      box-shadow: inset 0 0 0 3px var(--selection);
    }

    /* Last move highlight - from square */
    .square.last-move-from {
      background: var(--last-move) !important;
      box-shadow: inset 0 0 0 2px var(--last-move-border);
    }

    /* Last move highlight - to square */
    .square.last-move-to {
      background: var(--last-move) !important;
      box-shadow: inset 0 0 0 3px var(--last-move-border);
    }
    
    /* Valid move indicator - empty square */
    .square.valid-move::after {
      content: '';
      width: 28%;
      height: 28%;
      border-radius: 50%;
      background: rgba(76, 175, 80, 0.7);
      box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
      position: absolute;
      pointer-events: none;
      animation: pulse-move 1.5s ease-in-out infinite;
    }

    @keyframes pulse-move {
      0%, 100% { transform: scale(1); opacity: 0.7; }
      50% { transform: scale(1.15); opacity: 1; }
    }

    /* Valid capture indicator (for squares with opponent pieces) */
    .square.valid-capture {
      position: relative;
    }
    
    .square.valid-capture::before {
      content: '';
      position: absolute;
      top: 4px;
      left: 4px;
      right: 4px;
      bottom: 4px;
      border-radius: 50%;
      border: 4px solid rgba(244, 67, 54, 0.7);
      box-shadow: 0 0 12px rgba(244, 67, 54, 0.5), inset 0 0 12px rgba(244, 67, 54, 0.2);
      pointer-events: none;
      animation: pulse-capture 1.5s ease-in-out infinite;
    }

    @keyframes pulse-capture {
      0%, 100% { transform: scale(1); opacity: 0.7; }
      50% { transform: scale(1.05); opacity: 1; }
    }
    
    /* Hover effect: slight lift */
    .square:hover:not(.disabled) { 
      filter: brightness(1.15);
      transform: scale(1.02);
    }

    /* Disabled board (not your turn) */
    .board.disabled .square {
      cursor: not-allowed;
    }

    /* ===== Status Display Styles ===== */
    
    /* Status bar: Two-column grid for turn and game status */
    .status {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));  /* Equal columns */
      gap: 10px;
      margin: 0 0 12px;
    }

    /* Scoreboard: Two-column grid for player scores */
    .scoreboard {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin: 0 0 12px;
    }

    /* Card component: Container for status/score items */
    .card {
      background: rgba(255, 255, 255, 0.03);  /* Subtle background */
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 10px 12px;
      border-radius: 10px;
    }

    /* Label text in cards (e.g., "Turn", "Status") */
    .label { 
      color: var(--muted); 
      font-size: 11px; 
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* Value text in cards (e.g., "White", "Ongoing") */
    .value { 
      font-size: 16px; 
      font-weight: 600; 
    }

    /* ===== Button Styles ===== */
    
    /* Action buttons container */
    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;  /* Wrap on small screens */
      margin-bottom: 12px;
    }

    /* Primary action button (e.g., Reset Game) */
    button.action {
      padding: 8px 12px;
      border-radius: 8px;
      background: var(--accent);  /* Gold background */
      border: none;
      color: #1c1605;             /* Dark text for contrast */
      font-weight: 700;
      font-size: 13px;
      letter-spacing: 0.25px;
      cursor: pointer;
      /* Smooth hover animation */
      transition: transform 0.12s ease, box-shadow 0.12s ease;
      box-shadow: 0 4px 16px rgba(227, 179, 65, 0.3);  /* Gold glow */
    }

    /* Secondary button style (e.g., Refresh State) */
    button.action.secondary {
      background: rgba(255, 255, 255, 0.08);  /* Translucent background */
      color: var(--light);
      box-shadow: none;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Multiplayer button style */
    button.action.multiplayer {
      background: var(--accent-secondary);
      box-shadow: 0 4px 16px rgba(55, 178, 255, 0.3);
    }

    /* Leave/danger button style */
    button.action.danger {
      background: #ef4444;
      box-shadow: 0 4px 16px rgba(239, 68, 68, 0.3);
    }

    /* Button hover: Slight lift effect */
    button.action:hover { transform: translateY(-1px); }

    /* Disabled button state */
    button.action:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* ===== Collapsible Panel Styles ===== */
    .collapsible-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding: 8px 0;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Utility classes for inline style replacements */
    .mb-10 { margin-bottom: 10px; }
    .mb-12 { margin-bottom: 12px; }
    .hidden { display: none; }

    .collapsible-header h3 {
      margin: 0;
      font-size: 13px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .collapsible-toggle {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.05);
      color: var(--muted);
      font-size: 12px;
      transition: transform 0.2s ease;
    }

    .collapsible-content {
      overflow: hidden;
      transition: max-height 0.3s ease, opacity 0.3s ease;
      max-height: 500px;
      opacity: 1;
    }

    .collapsible-content.collapsed {
      max-height: 0;
      opacity: 0;
    }

    .collapsible-header.collapsed .collapsible-toggle {
      transform: rotate(-90deg);
    }

    /* ===== Log Display ===== */
    
    /* Message log area */
    .log {
      background: rgba(0, 0, 0, 0.22);  /* Dark background */
      border-radius: 10px;
      padding: 10px;
      min-height: 80px;
      max-height: 100px;
      overflow-y: auto;
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-size: 12px;
      line-height: 1.4;
      white-space: pre-wrap;
    }

    /* ===== Pill Badge Component ===== */
    
    /* Status pill with indicator dot */
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;  /* Fully rounded ends */
      padding: 5px 10px;
      font-size: 12px;
      color: var(--light);
    }

    /* Animated dot indicator before pill text */
    .pill::before {
      content: '';
      width: 8px;
      height: 8px;
      border-radius: 50%;  /* Circle */
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(227, 179, 65, 0.22);  /* Glow effect */
    }

    /* Multiplayer pill */
    .pill.multiplayer::before {
      background: var(--accent-secondary);
      box-shadow: 0 0 0 3px rgba(55, 178, 255, 0.22);
    }

    /* Waiting pill animation */
    .pill.waiting::before {
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }

    /* ===== Mode Selection Styles ===== */

    .mode-selector {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 12px;
    }

    .mode-btn {
      padding: 12px;
      border-radius: 10px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.03);
      color: var(--light);
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }

    .mode-btn:hover {
      border-color: var(--accent);
      background: rgba(227, 179, 65, 0.1);
    }

    .mode-btn.active {
      border-color: var(--accent);
      background: rgba(227, 179, 65, 0.15);
    }

    .mode-btn.multiplayer-btn:hover,
    .mode-btn.multiplayer-btn.active {
      border-color: var(--accent-secondary);
      background: rgba(55, 178, 255, 0.15);
    }

    .mode-btn h3 {
      margin: 0 0 2px;
      font-size: 14px;
    }

    .mode-btn p {
      margin: 0;
      font-size: 11px;
      color: var(--muted);
    }

    /* ===== Lobby Styles ===== */

    .lobby-panel {
      margin-bottom: 12px;
    }

    .lobby-input-group {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    .lobby-input {
      flex: 1;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(0, 0, 0, 0.2);
      color: var(--light);
      font-size: 14px;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .lobby-input::placeholder {
      text-transform: none;
      letter-spacing: normal;
      color: var(--muted);
    }

    .room-code-display {
      background: rgba(55, 178, 255, 0.1);
      border: 2px dashed var(--accent-secondary);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
      margin-bottom: 10px;
    }

    .room-code-display .code {
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 4px;
      color: var(--accent-secondary);
    }

    .room-code-display .hint {
      font-size: 11px;
      color: var(--muted);
      margin-top: 6px;
    }

    /* Player color indicator */
    .player-color {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 6px;
      font-weight: 600;
      font-size: 14px;
    }

    .player-color.white {
      background: rgba(255, 255, 255, 0.15);
    }

    .player-color.black {
      background: rgba(0, 0, 0, 0.4);
    }

    .player-color .piece {
      font-size: 18px;
    }

    /* Hide elements based on game mode */
    .single-player-only { display: none; }
    .multiplayer-only { display: none; }

    body.mode-single .single-player-only { display: block; }
    body.mode-single .multiplayer-only { display: none; }
    body.mode-multi .single-player-only { display: none; }
    body.mode-multi .multiplayer-only { display: block; }

    /* ===== Chat Styles ===== */

    .chat-panel {
      background: rgba(0, 0, 0, 0.22);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 0;
      overflow: hidden;
      margin-top: 12px;
    }

    .chat-header {
      padding: 10px 14px;
      background: rgba(255, 255, 255, 0.04);
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      font-weight: 600;
      font-size: 13px;
      color: var(--accent-secondary);
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    .chat-header .chat-toggle {
      font-size: 10px;
      color: var(--muted);
    }

    .chat-body {
      transition: max-height 0.3s ease;
      overflow: hidden;
    }

    .chat-body.collapsed {
      max-height: 0 !important;
    }

    .chat-messages {
      padding: 10px;
      height: 160px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .chat-message {
      display: flex;
      flex-direction: column;
      gap: 2px;
      padding: 6px 8px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.04);
      border-left: 3px solid;
    }

    .chat-message.white {
      border-left-color: rgba(255, 255, 255, 0.6);
    }

    .chat-message.black {
      border-left-color: rgba(0, 0, 0, 0.6);
      background: rgba(0, 0, 0, 0.2);
    }

    .chat-message.own {
      border-left-color: var(--accent-secondary);
      background: rgba(55, 178, 255, 0.1);
    }

    .chat-message-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
      margin-bottom: 2px;
    }

    .chat-sender {
      font-weight: 600;
      color: var(--accent);
    }

    .chat-timestamp {
      color: var(--muted);
      font-size: 10px;
    }

    .chat-text {
      color: var(--light);
      font-size: 12px;
      line-height: 1.4;
      word-wrap: break-word;
    }

    .chat-input-container {
      display: flex;
      gap: 6px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.04);
      border-top: 1px solid rgba(255, 255, 255, 0.06);
    }

    .chat-input {
      flex: 1;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      padding: 8px 10px;
      color: var(--light);
      font-family: inherit;
      font-size: 12px;
    }

    .chat-input:focus {
      outline: none;
      border-color: var(--accent-secondary);
      box-shadow: 0 0 0 2px rgba(55, 178, 255, 0.15);
    }

    .chat-input::placeholder {
      color: var(--muted);
    }

    .chat-send-btn {
      background: var(--accent-secondary);
      border: none;
      border-radius: 6px;
      padding: 8px 14px;
      color: #0f1629;
      font-weight: 600;
      font-size: 12px;
      cursor: pointer;
      transition: transform 0.12s ease;
    }

    .chat-send-btn:hover {
      transform: translateY(-1px);
    }

    .chat-send-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .chat-empty {
      text-align: center;
      color: var(--muted);
      font-size: 12px;
      padding: 30px 12px;
    }

    /* Custom scrollbar for chat */
    .chat-messages::-webkit-scrollbar {
      width: 5px;
    }

    .chat-messages::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    .chat-messages::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* ===== Responsive Design ===== */
    
    /* Mobile/tablet layout: Stack board and controls vertically */
    @media (max-width: 900px) {
      body { padding: 12px; }
      main { 
        flex-direction: column;
        align-items: center;
      }
      .side-panel {
        width: 100%;
        max-width: 500px;
      }
      .board {
        width: min(90vmin, 500px);
      }
    }
  </style>
</head>
<body class="mode-single">
  <main>
    <!-- Left Panel: Chess Board -->
    <section class="board-pane">
      <h1>‚ôüÔ∏è Chess Playground</h1>
      <p class="subtitle">Click a piece, then click where to move it.</p>
      <!-- 8x8 chess board grid (populated by JavaScript) -->
      <div id="board" class="board"></div>
    </section>

    <!-- Right Panel: Game Controls and Status -->
    <section class="side-panel">
      <!-- Mode Selection -->
      <div class="mode-selector" id="modeSelector">
        <button class="mode-btn active" id="singlePlayerBtn">
          <h3>ü§ñ vs AI</h3>
          <p>Play against computer</p>
        </button>
        <button class="mode-btn multiplayer-btn" id="multiplayerBtn">
          <h3>üë• Online</h3>
          <p>Play with a friend</p>
        </button>
      </div>

      <!-- Multiplayer Lobby (shown when in multiplayer mode) -->
      <div class="lobby-panel multiplayer-only" id="lobbyPanel">
        <div id="lobbyContent">
          <!-- Create or Join options -->
          <div id="lobbyOptions">
            <div class="actions mb-10">
              <button class="action multiplayer" id="createRoomBtn">Create Room</button>
            </div>
            <div class="lobby-input-group">
              <input type="text" class="lobby-input" id="roomCodeInput" placeholder="Enter room code" maxlength="6" />
              <button class="action multiplayer" id="joinRoomBtn">Join</button>
            </div>
          </div>

          <!-- Room info (shown when in a room) -->
          <div id="roomInfo" class="hidden">
            <div class="room-code-display">
              <div class="code" id="roomCodeDisplay">------</div>
              <div class="hint">Share this code with your opponent</div>
            </div>
            <div class="card mb-10">
              <div class="label">Playing as</div>
              <div class="value">
                <span class="player-color white" id="playerColorDisplay">
                  <span class="piece">‚ôî</span> White
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Turn and Status Display -->
      <div class="status">
        <div class="card">
          <div class="label">Turn</div>
          <div class="value" id="turn">‚Ä¶</div>
        </div>
        <div class="card">
          <div class="label">Status</div>
          <div class="value" id="status">‚Ä¶</div>
        </div>
      </div>

      <!-- Multiplayer-specific status -->
      <div class="card multiplayer-only mb-12" id="multiplayerStatus">
        <div class="label">Game Status</div>
        <div class="value">
          <span class="pill multiplayer waiting" id="mpStatusPill">Waiting for opponent...</span>
        </div>
      </div>

      <!-- Player Scores Display -->
      <div class="scoreboard">
        <div class="card">
          <div class="label single-player-only">Your Score</div>
          <div class="label multiplayer-only">White</div>
          <div class="value" id="playerScore">0</div>
        </div>
        <div class="card">
          <div class="label single-player-only">Opponent</div>
          <div class="label multiplayer-only">Black</div>
          <div class="value" id="opponentScore">0</div>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="actions">
        <button class="action" id="reset">Reset</button>
        <button class="action secondary" id="refresh">Refresh</button>
        <button class="action danger multiplayer-only hidden" id="leaveRoom">Leave</button>
      </div>

      <!-- Collapsible Details Section -->
      <div class="collapsible-section">
        <div class="collapsible-header" id="detailsHeader">
          <h3>Details</h3>
          <span class="collapsible-toggle">‚ñº</span>
        </div>
        <div class="collapsible-content" id="detailsContent">
          <!-- Current Selection Display -->
          <div class="card mb-10">
            <div class="label">Selection</div>
            <div class="value" id="selection">Pick any square</div>
          </div>
          <!-- Message Log -->
          <div class="log" id="log">Waiting for server‚Ä¶</div>
        </div>
      </div>

      <!-- Chat Panel (multiplayer only) -->
      <div class="chat-panel multiplayer-only hidden" id="chatPanel">
        <div class="chat-header" id="chatHeader">
          <span>üí¨ Game Chat</span>
          <span class="chat-toggle" id="chatToggleText">‚ñº</span>
        </div>
        <div class="chat-body" id="chatBody">
          <div class="chat-messages" id="chatMessages">
            <div class="chat-empty">No messages yet. Start the conversation!</div>
          </div>
          <div class="chat-input-container">
            <input 
              type="text" 
              class="chat-input" 
              id="chatInput" 
              placeholder="Type a message..." 
              maxlength="500"
            />
            <button class="chat-send-btn" id="chatSendBtn">Send</button>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // ===== DOM Element References =====
    const boardEl = document.getElementById('board');
    const turnEl = document.getElementById('turn');
    const statusEl = document.getElementById('status');
    const selectionEl = document.getElementById('selection');
    const logEl = document.getElementById('log');
    const playerScoreEl = document.getElementById('playerScore');
    const opponentScoreEl = document.getElementById('opponentScore');
    const resetBtn = document.getElementById('reset');
    const refreshBtn = document.getElementById('refresh');
    
    // Mode selection elements
    const singlePlayerBtn = document.getElementById('singlePlayerBtn');
    const multiplayerBtn = document.getElementById('multiplayerBtn');
    const modeSelector = document.getElementById('modeSelector');
    
    // Multiplayer elements
    const lobbyPanel = document.getElementById('lobbyPanel');
    const lobbyOptions = document.getElementById('lobbyOptions');
    const roomInfo = document.getElementById('roomInfo');
    const createRoomBtn = document.getElementById('createRoomBtn');
    const joinRoomBtn = document.getElementById('joinRoomBtn');
    const roomCodeInput = document.getElementById('roomCodeInput');
    const roomCodeDisplay = document.getElementById('roomCodeDisplay');
    const playerColorDisplay = document.getElementById('playerColorDisplay');
    const leaveRoomBtn = document.getElementById('leaveRoom');
    const mpStatusPill = document.getElementById('mpStatusPill');
    const multiplayerStatus = document.getElementById('multiplayerStatus');

    // Chat elements
    const chatPanel = document.getElementById('chatPanel');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');
    const chatHeader = document.getElementById('chatHeader');
    const chatBody = document.getElementById('chatBody');
    const chatToggleText = document.getElementById('chatToggleText');

    // Collapsible elements
    const detailsHeader = document.getElementById('detailsHeader');
    const detailsContent = document.getElementById('detailsContent');

    // ===== Chess Piece Mapping =====
    const pieceMap = {
      r: '‚ôú', n: '‚ôû', b: '‚ôù', q: '‚ôõ', k: '‚ôö', p: '‚ôü',
      R: '‚ôñ', N: '‚ôò', B: '‚ôó', Q: '‚ôï', K: '‚ôî', P: '‚ôô',
      '.': ''
    };

    // ===== Application State =====
    let selection = null;
    let cachedBoard = [];
    let opponentRefresh = null;
    let lastMove = null;  // Track last move for highlighting
    
    // Game mode state
    let gameMode = 'single'; // 'single' or 'multi'
    let roomCode = null;
    let playerId = null;
    let playerColor = null;
    let isInRoom = false;

    // Chat state
    let lastChatTimestamp = 0;
    let chatPollInterval = null;
    let isChatCollapsed = false;

    // ===== Utility Functions =====

    function algebraic(row, col) {
      const file = String.fromCodePoint('a'.codePointAt(0) + col);
      const rank = 8 - row;
      return `${file}${rank}`;
    }

    function squareToIndex(square) {
      const file = square.codePointAt(0) - 'a'.codePointAt(0);
      const rank = 8 - Number.parseInt(square[1], 10);
      return { row: rank, col: file };
    }

    function setMessage(text) {
      logEl.textContent = text;
    }

    function saveSession() {
      if (gameMode === 'multi' && roomCode && playerId) {
        localStorage.setItem('chess_session', JSON.stringify({
          roomCode, playerId, playerColor
        }));
      } else {
        localStorage.removeItem('chess_session');
      }
    }

    function loadSession() {
      try {
        const session = JSON.parse(localStorage.getItem('chess_session'));
        if (session && session.roomCode && session.playerId) {
          return session;
        }
      } catch (e) {
        // Invalid JSON in localStorage - clear it and return null
        console.debug('Invalid session data, clearing:', e);
        localStorage.removeItem('chess_session');
      }
      return null;
    }

    // ===== Board Rendering =====

    function renderBoard(boardRows, disabled = false, validMoves = []) {
      cachedBoard = boardRows;
      boardEl.innerHTML = '';
      boardEl.classList.toggle('disabled', disabled);
      
      // Parse last move for highlighting
      let lastMoveFrom = null;
      let lastMoveTo = null;
      if (lastMove && lastMove.length >= 4) {
        lastMoveFrom = lastMove.substring(0, 2);
        lastMoveTo = lastMove.substring(2, 4);
      }
      
      boardRows.forEach((rowString, rowIdx) => {
        [...rowString].forEach((ch, colIdx) => {
          const btn = document.createElement('button');
          const square = algebraic(rowIdx, colIdx);
          btn.className = `square ${(rowIdx + colIdx) % 2 === 0 ? 'dark' : 'light'}`;
          btn.dataset.square = square;
          btn.textContent = pieceMap[ch] ?? '';
          
          // Selected square highlight
          if (selection === square) {
            btn.classList.add('selected');
          }
          
          // Last move highlighting
          if (lastMoveFrom === square) {
            btn.classList.add('last-move-from');
          }
          if (lastMoveTo === square) {
            btn.classList.add('last-move-to');
          }
          
          // Add valid move indicators
          if (validMoves.includes(square)) {
            if (ch === '.') {
              btn.classList.add('valid-move');
            } else {
              btn.classList.add('valid-capture');
            }
          }
          
          if (!disabled) {
            btn.addEventListener('click', () => handleSquareClick(square));
          }
          
          boardEl.appendChild(btn);
        });
      });
    }

    // ===== Move Handling =====

    async function handleSquareClick(square) {
      if (!selection) {
        selection = square;
        selectionEl.textContent = `From ${square}`;
        
        // Fetch and display valid moves for the selected piece
        await loadValidMoves(square);
        return;
      }

      if (selection === square) {
        selection = null;
        selectionEl.textContent = 'Pick any square';
        renderBoard(cachedBoard, false);
        return;
      }

      const from = selection;
      const to = square;
      selection = null;
      selectionEl.textContent = 'Sending move‚Ä¶';
      
      if (gameMode === 'multi' && isInRoom) {
        sendOnlineMove(from, to);
      } else {
        sendMove(from, to);
      }
    }

    // ===== Single Player API =====

    async function sendMove(from, to) {
      try {
        const res = await fetch(`/api/move/${from}/${to}`, { method: 'POST' });
        const payload = await res.json();
        applyState(payload);
        selectionEl.textContent = 'Pick any square';
      } catch (err) {
        setMessage('Move failed: ' + err.message);
      }
    }

    async function loadState() {
      setMessage('Syncing with server‚Ä¶');
      try {
        const res = await fetch('/api/state');
        const payload = await res.json();
        applyState(payload);
      } catch (err) {
        console.error('Failed to load state:', err);
        setMessage('Could not reach the chess server.');
      }
    }

    async function resetGame() {
      setMessage('Resetting‚Ä¶');
      try {
        if (gameMode === 'multi' && isInRoom) {
          await resetOnlineGame();
        } else {
          const res = await fetch('/api/reset', { method: 'POST' });
          const payload = await res.json();
          lastMove = null;
          applyState(payload);
        }
      } catch (err) {
        setMessage('Reset failed: ' + err.message);
      }
    }

    function applyState(state) {
      if (!state || !state.board) {
        setMessage('Unexpected response from server.');
        return;
      }
      
      if (opponentRefresh !== null) {
        clearTimeout(opponentRefresh);
        opponentRefresh = null;
      }
      
      // Update last move for highlighting
      if (state.lastMove) {
        lastMove = state.lastMove;
      }
      
      renderBoard(state.board, false);
      turnEl.textContent = state.turn ?? '‚Äî';
      statusEl.textContent = state.status ?? '‚Äî';
      selectionEl.textContent = 'Pick any square';
      playerScoreEl.textContent = state.playerScore ?? 0;
      opponentScoreEl.textContent = state.opponentScore ?? 0;
      
      const move = state.lastMove ? `Last move: ${state.lastMove}` : 'Ready for a move';
      setMessage(`${state.message || 'Synced.'}\n${move}`);
      
      if (state.opponentPending) {
        opponentRefresh = setTimeout(loadState, 3100);
      }
    }

    // ===== Multiplayer API =====

    async function createRoom() {
      setMessage('Creating room‚Ä¶');
      try {
        const res = await fetch('/api/online/create', { method: 'POST' });
        const data = await res.json();
        
        if (data.roomCode && data.playerId) {
          roomCode = data.roomCode;
          playerId = data.playerId;
          playerColor = 'White';
          isInRoom = true;
          lastMove = null;
          
          saveSession();
          showRoomInfo();
          showChat();
          setMessage(data.message || 'Room created!');
          
          // Start polling for opponent
          startMultiplayerPolling();
        } else {
          setMessage('Failed to create room.');
        }
      } catch (err) {
        setMessage('Failed to create room: ' + err.message);
      }
    }

    async function joinRoom(code) {
      if (!code || code.length < 4) {
        setMessage('Please enter a valid room code.');
        return;
      }
      
      setMessage('Joining room‚Ä¶');
      try {
        const res = await fetch(`/api/online/join/${code.toUpperCase()}`, { method: 'POST' });
        const data = await res.json();
        
        // Extract playerId and playerColor from response
        if (data.playerId && data.roomCode) {
          roomCode = data.roomCode;
          playerId = data.playerId;
          playerColor = data.playerColor || 'Black';
          isInRoom = true;
          lastMove = null;
          
          saveSession();
          showRoomInfo();
          showChat();
          setMessage(data.message || 'Joined successfully!');
          
          // Load initial state and start polling
          applyOnlineState(data);
          startMultiplayerPolling();
        } else if (data.message) {
          // Error response
          setMessage(data.message);
        } else {
          setMessage('Failed to join room.');
        }
      } catch (err) {
        setMessage('Failed to join room: ' + err.message);
      }
    }

    async function loadOnlineState() {
      if (!roomCode || !playerId) return;
      
      try {
        const res = await fetch(`/api/online/state/${roomCode}/${playerId}`);
        const state = await res.json();
        applyOnlineState(state);
      } catch (err) {
        setMessage('Failed to load game state: ' + err.message);
      }
    }

    async function sendOnlineMove(from, to) {
      if (!roomCode || !playerId) return;
      
      try {
        const res = await fetch(`/api/online/move/${roomCode}/${playerId}/${from}/${to}`, {
          method: 'POST'
        });
        const state = await res.json();
        applyOnlineState(state);
        selectionEl.textContent = 'Pick any square';
      } catch (err) {
        setMessage('Move failed: ' + err.message);
      }
    }

    async function resetOnlineGame() {
      if (!roomCode || !playerId) return;
      
      try {
        const res = await fetch(`/api/online/reset/${roomCode}/${playerId}`, {
          method: 'POST'
        });
        const state = await res.json();
        lastMove = null;
        applyOnlineState(state);
      } catch (err) {
        setMessage('Reset failed: ' + err.message);
      }
    }

    async function leaveRoom() {
      if (!roomCode || !playerId) {
        exitMultiplayerMode();
        return;
      }
      
      try {
        await fetch(`/api/online/leave/${roomCode}/${playerId}`, { method: 'POST' });
      } catch (err) {
        // Ignore errors on leave - we're exiting anyway
        console.debug('Leave room error (ignored):', err);
      }
      
      exitMultiplayerMode();
      setMessage('You left the room.');
    }

    function applyOnlineState(state) {
      if (!state) {
        setMessage('Unexpected response from server.');
        return;
      }
      
      if (opponentRefresh !== null) {
        clearTimeout(opponentRefresh);
        opponentRefresh = null;
      }
      
      // Update last move for highlighting
      if (state.lastMove) {
        lastMove = state.lastMove;
      }
      
      // Update board (disabled if not your turn)
      const disabled = !state.isYourTurn && state.status === 'Ongoing';
      if (state.board && state.board.length > 0) {
        renderBoard(state.board, disabled);
      }
      
      turnEl.textContent = state.turn ?? '‚Äî';
      statusEl.textContent = state.status ?? '‚Äî';
      selectionEl.textContent = state.isYourTurn ? 'Your turn - pick a square' : 'Waiting for opponent';
      playerScoreEl.textContent = state.playerScore ?? 0;
      opponentScoreEl.textContent = state.opponentScore ?? 0;
      
      // Update multiplayer status pill
      if (state.waitingForOpponent) {
        mpStatusPill.textContent = 'Waiting for opponent to join...';
        mpStatusPill.classList.add('waiting');
      } else if (state.isYourTurn) {
        mpStatusPill.textContent = 'Your turn!';
        mpStatusPill.classList.remove('waiting');
      } else if (state.status === 'Ongoing') {
        mpStatusPill.textContent = "Opponent's turn...";
        mpStatusPill.classList.add('waiting');
      } else {
        mpStatusPill.textContent = state.status;
        mpStatusPill.classList.remove('waiting');
      }
      
      const move = state.lastMove ? `Last move: ${state.lastMove}` : '';
      setMessage(`${state.message || 'Synced.'}\n${move}`);
      
      // Continue polling while game is ongoing (to see opponent moves in real-time)
      if (state.status === 'Ongoing') {
        opponentRefresh = setTimeout(loadOnlineState, 1000);
      }
    }

    function startMultiplayerPolling() {
      if (opponentRefresh !== null) {
        clearTimeout(opponentRefresh);
      }
      loadOnlineState();
    }

    // ===== Valid Moves API =====

    async function loadValidMoves(square) {
      try {
        let url;
        if (gameMode === 'multi' && isInRoom && roomCode && playerId) {
          url = `/api/online/validmoves/${roomCode}/${playerId}/${square}`;
        } else {
          url = `/api/validmoves/${square}`;
        }

        const res = await fetch(url);
        const data = await res.json();

        if (data.success && data.validMoves) {
          renderBoard(cachedBoard, false, data.validMoves);
        } else {
          // No valid moves or error, just render normally
          renderBoard(cachedBoard, false);
        }
      } catch (err) {
        console.error('Failed to load valid moves:', err);
        renderBoard(cachedBoard, false);
      }
    }

    // ===== UI State Management =====

    function showRoomInfo() {
      lobbyOptions.classList.add('hidden');
      roomInfo.classList.remove('hidden');
      modeSelector.classList.add('hidden');
      leaveRoomBtn.classList.remove('hidden');
      
      roomCodeDisplay.textContent = roomCode || '------';
      
      if (playerColor === 'White') {
        playerColorDisplay.innerHTML = '<span class="piece">‚ôî</span> White';
        playerColorDisplay.className = 'player-color white';
      } else {
        playerColorDisplay.innerHTML = '<span class="piece">‚ôö</span> Black';
        playerColorDisplay.className = 'player-color black';
      }
    }

    function showLobbyOptions() {
      lobbyOptions.classList.remove('hidden');
      roomInfo.classList.add('hidden');
      modeSelector.classList.remove('hidden');
      leaveRoomBtn.classList.add('hidden');
    }

    function setGameMode(mode) {
      gameMode = mode;
      document.body.classList.remove('mode-single', 'mode-multi');
      document.body.classList.add(mode === 'single' ? 'mode-single' : 'mode-multi');
      
      singlePlayerBtn.classList.toggle('active', mode === 'single');
      multiplayerBtn.classList.toggle('active', mode === 'multi');
      
      if (mode === 'single') {
        if (opponentRefresh !== null) {
          clearTimeout(opponentRefresh);
          opponentRefresh = null;
        }
        lastMove = null;
        hideChat();
        loadState();
      } else {
        showLobbyOptions();
      }
    }

    function exitMultiplayerMode() {
      roomCode = null;
      playerId = null;
      playerColor = null;
      isInRoom = false;
      lastMove = null;
      localStorage.removeItem('chess_session');
      
      if (opponentRefresh !== null) {
        clearTimeout(opponentRefresh);
        opponentRefresh = null;
      }

      stopChatPolling();
      clearChat();
      
      showLobbyOptions();
      renderBoard(['rnbqkbnr', 'pppppppp', '........', '........', '........', '........', 'PPPPPPPP', 'RNBQKBNR'], true);
    }

    // ===== Chat Functions =====

    async function sendChatMessage(message) {
      if (!roomCode || !playerId || !message || message.trim().length === 0) {
        return;
      }

      // Disable send button while sending
      chatSendBtn.disabled = true;

      try {
        const res = await fetch(`/api/chat/send/${roomCode}/${playerId}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ message: message.trim() })
        });
        const data = await res.json();
        
        if (data.success) {
          chatInput.value = '';
          // Immediately load new messages
          await loadChatMessages();
        } else {
          console.error('Failed to send message:', data.error);
          setMessage('Chat error: ' + (data.error || 'Failed to send message'));
        }
      } catch (err) {
        console.error('Error sending message:', err);
        setMessage('Chat error: Could not send message');
      } finally {
        chatSendBtn.disabled = false;
        chatInput.focus();
      }
    }

    async function loadChatMessages() {
      if (!roomCode || !playerId) return;

      try {
        const res = await fetch(`/api/chat/history/${roomCode}/${playerId}?limit=100`);
        const data = await res.json();
        
        if (data.success && data.messages) {
          displayChatMessages(data.messages);
          if (data.messages.length > 0) {
            // Use the last message timestamp for polling
            lastChatTimestamp = Math.max(...data.messages.map(m => m.timestamp));
          }
        }
      } catch (err) {
        console.error('Error loading chat messages:', err);
      }
    }

    async function pollNewChatMessages() {
      if (!roomCode || !playerId) return;

      try {
        // Use lastChatTimestamp for polling, or 0 if we don't have any messages yet
        const since = lastChatTimestamp || 0;
        const res = await fetch(`/api/chat/recent/${roomCode}/${playerId}/${since}`);
        const data = await res.json();
        
        if (data.success && data.messages && data.messages.length > 0) {
          appendChatMessages(data.messages);
          // Update timestamp to the latest message
          lastChatTimestamp = Math.max(...data.messages.map(m => m.timestamp));
        }
      } catch (err) {
        console.error('Error polling chat messages:', err);
      }
    }

    function displayChatMessages(messages) {
      chatMessages.innerHTML = '';
      
      if (!messages || messages.length === 0) {
        chatMessages.innerHTML = '<div class="chat-empty">No messages yet. Start the conversation!</div>';
        return;
      }

      messages.forEach(msg => {
        const messageEl = createChatMessageElement(msg);
        chatMessages.appendChild(messageEl);
      });
      
      scrollChatToBottom();
    }

    function appendChatMessages(messages) {
      if (!messages || messages.length === 0) return;
      
      // Remove empty message if present
      const emptyMsg = chatMessages.querySelector('.chat-empty');
      if (emptyMsg) {
        emptyMsg.remove();
      }

      messages.forEach(msg => {
        const messageEl = createChatMessageElement(msg);
        chatMessages.appendChild(messageEl);
      });
      
      scrollChatToBottom();
    }

    function createChatMessageElement(msg) {
      const div = document.createElement('div');
      const isOwnMessage = msg.playerId === playerId;
      const colorClass = msg.playerColor.toLowerCase();
      
      div.className = `chat-message ${colorClass}${isOwnMessage ? ' own' : ''}`;
      
      // Handle timestamp - could be seconds or milliseconds
      let timestamp = msg.timestamp;
      // If timestamp is in seconds (less than year 2000 in ms), convert to ms
      if (timestamp < 946684800000) {
        timestamp = timestamp * 1000;
      }
      const time = new Date(timestamp);
      const timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      div.innerHTML = `
        <div class="chat-message-header">
          <span class="chat-sender">${isOwnMessage ? 'You' : msg.playerColor}</span>
          <span class="chat-timestamp">${timeStr}</span>
        </div>
        <div class="chat-text">${escapeHtml(msg.message)}</div>
      `;
      
      return div;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function scrollChatToBottom() {
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function clearChat() {
      chatMessages.innerHTML = '<div class="chat-empty">No messages yet. Start the conversation!</div>';
      chatInput.value = '';
      lastChatTimestamp = 0;
    }

    function showChat() {
      chatPanel.classList.remove('hidden');
      isChatCollapsed = false;
      chatBody.classList.remove('collapsed');
      chatToggleText.textContent = '‚ñº';
      loadChatMessages();
      startChatPolling();
    }

    function hideChat() {
      chatPanel.classList.add('hidden');
      stopChatPolling();
    }

    function toggleChat() {
      isChatCollapsed = !isChatCollapsed;
      chatBody.classList.toggle('collapsed', isChatCollapsed);
      chatToggleText.textContent = isChatCollapsed ? '‚ñ∂' : '‚ñº';
    }

    function startChatPolling() {
      stopChatPolling();
      // Poll for new messages every 2 seconds
      chatPollInterval = setInterval(pollNewChatMessages, 2000);
    }

    function stopChatPolling() {
      if (chatPollInterval !== null) {
        clearInterval(chatPollInterval);
        chatPollInterval = null;
      }
    }

    // ===== Collapsible Panel Functions =====
    function toggleDetails() {
      detailsContent.classList.toggle('collapsed');
      detailsHeader.classList.toggle('collapsed');
    }

    // ===== Event Listeners =====

    resetBtn.addEventListener('click', resetGame);
    refreshBtn.addEventListener('click', () => {
      if (gameMode === 'multi' && isInRoom) {
        loadOnlineState();
      } else {
        loadState();
      }
    });

    singlePlayerBtn.addEventListener('click', () => setGameMode('single'));
    multiplayerBtn.addEventListener('click', () => setGameMode('multi'));

    createRoomBtn.addEventListener('click', createRoom);
    joinRoomBtn.addEventListener('click', () => joinRoom(roomCodeInput.value));
    roomCodeInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') joinRoom(roomCodeInput.value);
    });
    leaveRoomBtn.addEventListener('click', leaveRoom);

    // Chat event listeners
    chatSendBtn.addEventListener('click', () => {
      const message = chatInput.value.trim();
      if (message) {
        sendChatMessage(message);
      }
    });

    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const message = chatInput.value.trim();
        if (message) {
          sendChatMessage(message);
        }
      }
    });

    // Chat header toggle
    chatHeader.addEventListener('click', toggleChat);

    // Details panel toggle
    detailsHeader.addEventListener('click', toggleDetails);

    // ===== Initialization =====

    // Check for existing session and initialize
    (async () => {
      const savedSession = loadSession();
      if (savedSession) {
        gameMode = 'multi';
        roomCode = savedSession.roomCode;
        playerId = savedSession.playerId;
        playerColor = savedSession.playerColor;
        isInRoom = true;
        
        document.body.classList.remove('mode-single');
        document.body.classList.add('mode-multi');
        multiplayerBtn.classList.add('active');
        singlePlayerBtn.classList.remove('active');
        
        showRoomInfo();
        showChat();
        startMultiplayerPolling();
      } else {
        // Default to single player mode
        await loadState();
      }
    })();
  </script>
</body>
</html>
